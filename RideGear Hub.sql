-- Retrieve all columns for a specific table (dim_customers)
SELECT 
    COLUMN_NAME, 
    DATA_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'dim_customers';


-- Retrieve all columns for a specific table (dim_products)
SELECT 
    COLUMN_NAME, 
    DATA_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'dim_products';

-- Retrieve all columns for a specific table (fact_sales)
SELECT 
    COLUMN_NAME, 
    DATA_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'fact_sales';





/*
===============================================================================
Purpose:
    - To explore the structure of dimension tables.
	
SQL Functions Used:
    - DISTINCT
    - ORDER BY
===============================================================================
*/

-- Retrieve a list of unique countries from which customers originate
select * from sales_data_sql_project.dim_customers limit 5;
-- and 
SELECT DISTINCT 
    country 
FROM sales_data_sql_project.dim_customers
ORDER BY country;

-- Retrieve a list of unique categories, subcategories, and products
select * from sales_data_sql_project.dim_products limit 5;
-- and
SELECT DISTINCT 
    category, 
    subcategory, 
    product_name
FROM sales_data_sql_project.dim_products
ORDER BY category, subcategory, product_name ;



/*
===============================================================================
Purpose:
    - To calculate aggregated metrics (e.g., totals, averages) for quick insights.
    - To identify overall trends or spot anomalies.
===============================================================================
*/

-- Generate a Report that shows all key metrics of the business
SELECT 'Total Sales' AS measure_name, SUM(sales_amount) AS measure_value FROM sales_data_sql_project.fact_sales
UNION ALL
SELECT 'Total Quantity', SUM(quantity) FROM sales_data_sql_project.fact_sales
UNION ALL
SELECT 'Average Price', AVG(price) FROM sales_data_sql_project.fact_sales
UNION ALL
SELECT 'Total Orders', COUNT(DISTINCT order_number) FROM sales_data_sql_project.fact_sales
UNION ALL
SELECT 'Total Products', COUNT(DISTINCT product_name) FROM sales_data_sql_project.dim_products
UNION ALL
SELECT 'Total Customers', COUNT(customer_key) FROM sales_data_sql_project.dim_customers;




/*
===============================================================================
Purpose:
    - To quantify data and group results by specific dimensions.
    - For understanding data distribution across categories.
===============================================================================
*/

-- Find total customers by countries
SELECT
    country,
    COUNT(customer_key) AS total_customers
FROM sales_data_sql_project.dim_customers
GROUP BY country
ORDER BY total_customers DESC;

-- Find total customers by gender
SELECT
    gender,
    COUNT(customer_key) AS total_customers
FROM sales_data_sql_project.dim_customers
GROUP BY gender
ORDER BY total_customers DESC;

-- Find total products by category
SELECT
    category,
    COUNT(product_key) AS total_products
FROM sales_data_sql_project.dim_products
GROUP BY category
ORDER BY total_products DESC;

-- What is the average costs in each category?
SELECT
    category,
    AVG(cost) AS avg_cost
FROM sales_data_sql_project.dim_products
GROUP BY category
ORDER BY avg_cost DESC;

-- What is the total revenue generated for each category?
SELECT
    p.category,
    SUM(f.sales_amount) AS total_revenue
FROM sales_data_sql_project.fact_sales f
LEFT JOIN sales_data_sql_project.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.category
ORDER BY total_revenue DESC;


-- What is the total revenue generated by each customer?
SELECT
    c.customer_key,
    c.first_name,
    c.last_name,
    SUM(f.sales_amount) AS total_revenue
FROM sales_data_sql_project.fact_sales f
LEFT JOIN sales_data_sql_project.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_revenue DESC;

-- What is the distribution of sold items across countries?
SELECT
    c.country,
    SUM(f.quantity) AS total_sold_items
FROM sales_data_sql_project.fact_sales f
LEFT JOIN sales_data_sql_project.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY c.country
ORDER BY total_sold_items DESC;




/*
===============================================================================
Purpose:
    - To rank items (e.g., products, customers) based on performance or other metrics.
    - To identify top performers or laggards.
===============================================================================
*/

-- Which 5 products Generating the Highest Revenue?
-- Simple Ranking
SELECT 
    p.product_name,
    SUM(f.sales_amount) AS total_revenue
FROM sales_data_sql_project.fact_sales f
JOIN sales_data_sql_project.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue DESC
limit 5;

-- Complex but Flexibly Ranking Using Window Functions
SELECT *
FROM (
    SELECT
        p.product_name,
        SUM(f.sales_amount) AS total_revenue,
        RANK() OVER (ORDER BY SUM(f.sales_amount) DESC) AS rank_products
    FROM sales_data_sql_project.fact_sales f
    JOIN sales_data_sql_project.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.product_name
) AS ranked_products
WHERE rank_products <= 5;

-- What are the 5 worst-performing products in terms of sales?
SELECT 
    p.product_name,
    SUM(f.sales_amount) AS total_revenue
FROM sales_data_sql_project.fact_sales f
JOIN sales_data_sql_project.dim_products p
    ON p.product_key = f.product_key
GROUP BY p.product_name
ORDER BY total_revenue
limit 5;

-- Find the top 10 customers who have generated the highest revenue
SELECT 
    c.customer_key,
    concat(c.first_name," ",c.last_name) as Customer_Name,
    SUM(f.sales_amount) AS total_revenue
FROM sales_data_sql_project.fact_sales f
JOIN sales_data_sql_project.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
	Customer_Name
 ORDER BY total_revenue DESC
limit 10 ;

-- The 3 customers with the fewest orders placed
with customer_with_lowest_order as(
SELECT
    c.customer_key,
    c.first_name,
    c.last_name,
    COUNT(DISTINCT order_number) AS total_orders
FROM sales_data_sql_project.fact_sales f
LEFT JOIN sales_data_sql_project.dim_customers c
    ON c.customer_key = f.customer_key
GROUP BY 
    c.customer_key,
    c.first_name,
    c.last_name
ORDER BY total_orders )

select * from customer_with_lowest_order where total_orders = 1
;



/*
===============================================================================
Purpose:
    - To track trends, growth, and changes in key metrics over time.
    - For time-series analysis and identifying seasonality.
    - To measure growth or decline over specific periods.
===============================================================================
*/

-- Analyse sales performance over time
-- Quick Date Functions
SELECT
    YEAR(order_date) AS order_year,
    MONTH(order_date) AS order_month,
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers,
    SUM(quantity) AS total_quantity
FROM sales_data_sql_project.fact_sales
WHERE YEAR(order_date) IS NOT NULL
GROUP BY YEAR(order_date), MONTH(order_date)
ORDER BY YEAR(order_date), MONTH(order_date);

-- FORMAT 
SELECT 
    DATE_FORMAT(order_date, '%Y-%m-01') AS order_date,  -- Truncate to first day of the month
    SUM(sales_amount) AS total_sales,
    COUNT(DISTINCT customer_key) AS total_customers,
    SUM(quantity) AS total_quantity
FROM sales_data_sql_project.fact_sales
WHERE DATE_FORMAT(order_date, '%Y-%m-01') IS NOT NULL
GROUP BY DATE_FORMAT(order_date, '%Y-%m-01')
ORDER BY DATE_FORMAT(order_date, '%Y-%m-01');



/*
===============================================================================
Purpose:
    - To calculate running totals or moving averages for key metrics.
    - To track performance over time cumulatively.
    - Useful for growth analysis or identifying long-term trends.
===============================================================================
*/

-- Calculate the total sales per month 
-- and the running total of sales over time 

with t2 as
(
	SELECT
		order_date,
		total_sales,
		AVG(avg_price) OVER (ORDER BY order_date rows between unbounded preceding and current row) AS moving_average_price,
		SUM(total_sales) OVER (ORDER BY order_date rows between unbounded preceding and current row) AS running_total_sales
	FROM
	(
		SELECT 
			date_FORMAT(order_date,'%Y-%m-01') AS order_date,
			SUM(sales_amount) AS total_sales,
			round(AVG(price),2) AS avg_price
		FROM sales_data_sql_project.fact_sales
		WHERE date_FORMAT(order_date,'%Y-%m-01') IS NOT NULL
		GROUP BY date_FORMAT(order_date,'%Y-%m-01')
	) t
)
select order_date ,
	total_sales ,
    round(moving_average_price,2) as moving_average_price,
    running_total_sales
from t2;




/*
===============================================================================
Purpose:
    - To measure the performance of products, customers, or regions over time.
    - For benchmarking and identifying high-performing entities.
    - To track yearly trends and growth.
===============================================================================
*/

/* Analyze the yearly performance of products by comparing their sales 
to both the average sales performance of the product and the previous year's sales */
WITH yearly_product_sales AS (
    SELECT
        YEAR(f.order_date) AS order_year,
        p.product_name,
        SUM(f.sales_amount) AS current_sales
    FROM sales_data_sql_project.fact_sales f
    LEFT JOIN sales_data_sql_project.dim_products p
        ON f.product_key = p.product_key
    WHERE YEAR(f.order_date) IS NOT NULL
    GROUP BY 
        YEAR(f.order_date),
        p.product_name
)
SELECT
    order_year,
    product_name,
    current_sales,
    AVG(current_sales) OVER (PARTITION BY product_name) AS avg_sales,
    current_sales - AVG(current_sales) OVER (PARTITION BY product_name) AS diff_avg,
    CASE 
        WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) > 0 THEN 'Above Avg'
        WHEN current_sales - AVG(current_sales) OVER (PARTITION BY product_name) < 0 THEN 'Below Avg'
        ELSE 'Avg'
    END AS avg_change,
    -- Year-over-Year Analysis
    LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS py_sales,
    current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) AS diff_py,
    CASE 
        WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) > 0 THEN 'Increase'
        WHEN current_sales - LAG(current_sales) OVER (PARTITION BY product_name ORDER BY order_year) < 0 THEN 'Decrease'
        ELSE 'No Change'
    END AS py_change
FROM yearly_product_sales
ORDER BY product_name, order_year;






/*
===============================================================================
Purpose:
    - To group data into meaningful categories for targeted insights.
    - For customer segmentation, product categorization, or regional analysis.
===============================================================================
*/

/*Segment products into cost ranges and 
count how many products fall into each segment*/
WITH product_segments AS (
    SELECT
        product_key,
        product_name,
        cost,
        CASE 
            WHEN cost < 100 THEN 'Below 100'
            WHEN cost BETWEEN 100 AND 500 THEN '100-500'
            WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
            ELSE 'Above 1000'
        END AS cost_range
    FROM sales_data_sql_project.dim_products
)
SELECT 
    cost_range,
    COUNT(product_key) AS total_products
FROM product_segments
GROUP BY cost_range
ORDER BY total_products DESC;


/*Group customers into three segments based on their spending behavior:
	- VIP: Customers with at least 12 months of history and spending more than €5,000.
	- Regular: Customers with at least 12 months of history but spending €5,000 or less.
	- New: Customers with a lifespan less than 12 months.
And find the total number of customers by each group
*/
WITH 
customer_spending AS (
    SELECT
        c.customer_key,
        SUM(f.sales_amount) AS total_spending,
        MIN(order_date) AS first_order,
        MAX(order_date) AS last_order,
        timestampdiff(month,MIN(order_date),MAX(order_date)) AS lifespan
    FROM sales_data_sql_project.fact_sales f
    LEFT JOIN sales_data_sql_project.dim_customers c
        ON f.customer_key = c.customer_key
	where f.order_date is not null
    GROUP BY c.customer_key
),
segmented_customers as (
	SELECT 
		customer_key,
		CASE 
			WHEN lifespan >= 12 AND total_spending > 5000 THEN 'VIP'
			WHEN lifespan >= 12 AND total_spending <= 5000 THEN 'Regular'
			ELSE 'New'
		END AS customer_segment
	FROM customer_spending
	) 
SELECT 
    customer_segment,
    COUNT(customer_key) AS total_customers
FROM segmented_customers
GROUP BY customer_segment
ORDER BY total_customers DESC;



/*
===============================================================================
Purpose:
    - To compare performance or metrics across dimensions or time periods.
    - To evaluate differences between categories.
    - Useful for A/B testing or regional comparisons.
===============================================================================
*/
-- Which categories contribute the most to overall sales?
WITH category_sales AS (
    SELECT
        p.category,
        SUM(f.sales_amount) AS total_sales
    FROM sales_data_sql_project.fact_sales f
    LEFT JOIN sales_data_sql_project.dim_products p
        ON p.product_key = f.product_key
    GROUP BY p.category
)
SELECT
    category,
    total_sales,
    SUM(total_sales) OVER () AS overall_sales,
    concat(round((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER ()) * 100, 2)," %") AS percentage_of_total
FROM category_sales
ORDER BY total_sales DESC;